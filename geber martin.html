<!doctype html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
    <title>GEBER LIGHTING — FIXED + SAVE/LOAD PROJECT</title>
    <style>
    :root{
      --bg:#000;
      --panel:#07121a;
      --accent:#00d4ff;
      --muted:#9fb0c4;
      --btn:#0b3740;
    }
    *{box-sizing:border-box}
    html,body{height:100%;margin:0;background:var(--bg);color:#eaf6ff;font-family:Inter,system-ui,Arial,sans-serif}
    #app{display:flex;flex-direction:column;height:100vh;overflow:hidden}
    #stageWrap{flex:1;position:relative;background:#000;overflow:hidden;height:100vh;}
    canvas#stage{position:absolute;left:0;top:0;width:100%;height:100%;z-index:1;touch-action:none}
    /* Panel */
    .panel{flex:0 0 auto;background:var(--panel);padding:10px;overflow-y:auto;max-height:44%;display:flex;flex-direction:column;gap:10px}
    .row{display:flex;gap:8px;flex-wrap:wrap}
    .col{flex:1;display:flex;flex-direction:column}
    .label{font-size:12px;color:var(--muted);margin-bottom:4px}
    .small{font-size:12px;color:var(--muted);text-align:center}
    input[type=range]{width:100%}
    input[type=color]{appearance:none;border:none;padding:0;margin:0;width:44px;height:36px;border-radius:6px;cursor:pointer}
    button,select{padding:10px;border-radius:10px;border:none;background:var(--btn);color:#eaf6ff;font-weight:700;cursor:pointer}
    .bigBtn{background:linear-gradient(90deg,var(--accent),#006b7a);color:#001922;font-weight:900}
    .presetRow{display:flex;gap:6px;overflow-x:auto;padding-bottom:6px}
    .presetBox{background:#092023;padding:6px;border-radius:10px;display:flex;flex-direction:column;align-items:center;min-width:64px}
    .presetFader{height:120px;writing-mode:bt-lr;-webkit-appearance:slider-vertical}
    .fileRow{display:flex;gap:8px;align-items:center}
    .footer{text-align:center;font-size:11px;color:#7da;margin-top:6px}
    .smallBtn{padding:6px;border-radius:8px;background:#0e2b2f;font-weight:700}
    .controlGroup{display:flex;gap:6px;align-items:center}
    /* Grid for Strobe and Prisma Buttons */
    .strobe-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 6px;
    }
    .strobe-btn, .prisma-btn {
      padding: 6px 4px;
      border-radius: 6px;
      font-weight: 500;
      font-size: 11px;
      background: #0b3740;
    }
    .strobe-btn.active, .prisma-btn.active {
      background: var(--accent);
      color: var(--panel);
      font-weight: 700;
    }
    @media(min-width:920px){
      #app{flex-direction:row}
      #stageWrap{flex:1}
      .panel{width:420px;height:100vh;max-height:none;overflow:auto}
    }
    </style>
</head>
<body>
<!-- Pesan selamat datang -->
<div id="welcome" style="
  text-align:center;
  background:#000;
  color:#00d4ff;
  padding:10px;
  font-family:sans-serif;
  opacity:1;
  transition:opacity 1s ease;
">
  <b>GEBER LIGHTING</b><br>
  MASIH KEADAAN BETA YO KALO BUG KABARIN
</div>
<script>
// Hilang dengan efek fade-out setelah 3 detik
setTimeout(() => {
  const w = document.getElementById("welcome");
  w.style.opacity = "0";
  setTimeout(() => w.style.display = "none", 1000); // tunggu animasi selesai
}, 3000);
</script>
<div id="app">
  <div id="stageWrap">
    <canvas id="stage" aria-label="Lighting Stage"></canvas>
  </div>
  <div class="panel" id="panel">
    <button id="powerBtn" class="bigBtn">POWER ON</button>

    <!-- === SAVE / LOAD PROJECT BUTTONS === -->
    <div class="row" style="margin-top:10px;">
      <button id="saveProjectBtn" class="smallBtn">Save Project</button>
      <input type="file" id="loadProjectInput" accept=".geber,.json" style="display:none">
      <button id="loadProjectBtn" class="smallBtn">Load Project</button>
    </div>

    <div class="row">
      <div class="col">
        <div class="label">Jumlah Beam</div>
        <input id="beamCount" type="range" min="2" max="30" step="2" value="8">
        <div class="small">Beams: <span id="beamCountLabel">8</span></div>
      </div>
      <div class="col">
        <div class="label">Dimmer</div>
        <input id="dimmer" type="range" min="0" max="100" value="95">
      </div>
    </div>
    <div class="row">
      <div class="col"><div class="label">Beam Angle (°)</div><input id="beamAngle" type="range" min="5" max="40" value="12"></div>
      <div class="col"><div class="label">Beam Range (px)</div><input id="beamRange" type="range" min="200" max="1600" value="900"></div>
    </div>
    <div class="row">
      <div class="col"><div class="label">Global Warna</div><input id="globalColor" type="color" value="#ffffff"></div>
      <div class="col"><div class="label">Rainbow</div><button id="rainbowBtn">RAINBOW OFF</button></div>
      <div class="col"><div class="label">Gobo Aurora</div><button id="goboBtn">AURORA OFF</button></div>
    </div>
    <div class="row">
      <div class="col">
        <div class="label">Prisma Mode</div>
        <div id="prismaButtons" class="strobe-grid">
          <button data-mode="none" class="prisma-btn active">OFF</button>
          <button data-mode="split3" class="prisma-btn">1 (gobo1)</button>
          <button data-mode="split5" class="prisma-btn">2 (prisma 5)</button>
          <button data-mode="split7" class="prisma-btn">3 (kepyar)</button>
          <button data-mode="linear" class="prisma-btn">4 (Linear)</button>
          <button data-mode="combo" class="prisma-btn">5 (Combo)</button>
        </div>
      </div>
      <div class="col"><div class="label">Color </div><button id="crossColorBtn">Color OFF</button></div>
      <div class="col"><div class="label">Mini Brute</div><button id="miniBruteToggle">BRUTE OFF</button></div>
    </div>
    <div class="row">
      <div class="col"><div class="label">Strobe Mode</div>
<div id="strobeButtons" class="strobe-grid">
  <button data-mode="off" class="strobe-btn active">OFF</button>
  <button data-mode="blink" class="strobe-btn">1</button>
  <button data-mode="flow" class="strobe-btn">2</button>
  <button data-mode="random" class="strobe-btn">3</button>
  <button data-mode="alternate" class="strobe-btn">4</button>
  <button data-mode="chase" class="strobe-btn">5</button>
  <button data-mode="converge" class="strobe-btn">6</button>
  <button data-mode="split" class="strobe-btn">7</button>
</div>
      </div>
      <div class="col"><div class="label">Strobe Speed (Hz)</div><input id="strobeSpeed" type="range" min="1" max="80" value="14">
      <div class="col"><div class="label">Beam Speed</div><input id="presetSpeed" type="range" min="0.1" max="3" step="0.1" value="1"></div>
      </div>
    </div>
    <div><div class="label">Presets Gerakan (dorong 100% untuk aktif)</div><div class="presetRow" id="autoPresets"></div></div>
    <div style="margin-top:6px">
      <div class="label">Chase Recorder (5 slot)</div>
      <div class="row" id="chaseControls"></div>
    </div>
    <div class="row">
      <div class="col"><div class="label">Mode</div><select id="modeSelect"><option value="auto">Auto</option><option value="manual">Manual</option></select></div>
      <div class="col"><div class="label">Manual Head</div><select id="manualHeadSelect"></select></div>
    </div>
    <div id="manualArea" style="display:none">
      <div class="label">Pan / Tilt</div>
      <div class="row"><input id="manualPan" type="range" min="-180" max="180" value="0"><input id="manualTilt" type="range" min="-60" max="10" value="-12"></div>
      <div class="label">Quick Colors</div>
      <div class="row" id="colorPresets">
        <button class="smallBtn" data-color="#ff0000" style="background:#ff0000;color:#000">R</button>
        <button class="smallBtn" data-color="#00ff00" style="background:#00ff00;color:#000">G</button>
        <button class="smallBtn" data-color="#0000ff" style="background:#0000ff;color:#fff">B</button>
        <button class="smallBtn" data-color="#ffffff" style="background:#fff;color:#000">W</button>
        <button class="smallBtn" data-color="#ffff00" style="background:#ffff00;color:#000">Y</button>
      </div>
      <div style="margin-top:8px"><input id="manualColor" type="color" value="#ffffff"></div>
      <div class="row" style="margin-top:8px">
        <button id="saveHeadA" class="smallBtn">Save→A</button>
        <button id="loadHeadA" class="smallBtn">Load←A</button>
        <button id="saveHeadB" class="smallBtn">Save→B</button>
        <button id="loadHeadB" class="smallBtn">Load←B</button>
      </div>
      <div class="row" style="margin-top:6px">
        <button id="saveAll" class="smallBtn">Save All</button>
        <button id="loadAll" class="smallBtn">Load All</button>
        <button id="clearSlots" class="smallBtn">Clear</button>
      </div>
    </div>
<div class="label">Video Background (seting vidio tron di apk am</div>
<div class="fileRow">
  <input id="tronVideoFile" type="file" accept="video/*">
  <button id="playTron" class="smallBtn">Play Tron</button>
  <button id="pauseTron" class="smallBtn">Pause Tron</button>
  <button id="clearTron" class="smallBtn">Clear Tron</button>
  </div>
<!-- === MARTIN STROBO CONTROLS === -->
<div style="margin-top:6px">
  <div class="label">Martin Strobo Controls</div>
  <div class="row">
    <div class="col">
      <div class="label">Jumlah Martin Strobo</div>
      <input id="martinCount" type="range" min="0" max="8" step="1" value="2">
      <div class="small">Martins: <span id="martinCountLabel">2</span></div>
    </div>
    <div class="col">
      <div class="label">Spawn / Reset</div>
      <div class="controlGroup">
        <button id="spawnMartin" class="smallBtn">Spawn</button>
        <button id="clearMartin" class="smallBtn">Clear</button>
      </div>
    </div>
  </div>
</div>
    <div style="margin-top:6px">
      <div class="label">Wallwasher Controls</div>
      <div class="row">
        <div class="col">
          <div class="label">Jumlah Wallwasher</div>
          <input id="wallCount" type="range" min="0" max="8" step="1" value="3">
          <div class="small">Wallwashers: <span id="wallCountLabel">3</span></div>
        </div>
        <div class="col">
          <div class="label">Spawn / Reset</div>
          <div class="controlGroup">
            <button id="spawnWall" class="smallBtn">Spawn</button>
            <button id="clearWall" class="smallBtn">Clear</button>
          </div>
        </div>
      </div>
    </div>
    <div style="margin-top:6px">
      <div class="label">ParLED Controls</div>
      <div class="row">
        <div class="col">
          <div class="label">Jumlah Parled</div>
          <input id="parCount" type="range" min="0" max="12" step="1" value="4">
          <div class="small">Parleds: <span id="parCountLabel">4</span></div>
        </div>
        <div class="col">
          <div class="label">Spawn / Reset</div>
          <div class="controlGroup">
            <button id="spawnPar" class="smallBtn">Spawn</button>
            <button id="clearPar" class="smallBtn">Clear</button>
          </div>
          <input type="range" min="1" max="8" value="4" id="miniBruteCount">
<button onclick="spawnMiniBrutes(parseInt(document.getElementById('miniBruteCount').value))">
  Spawn MiniBrute
</button>
        </div>
      </div>
    </div>
    <div class="row" style="margin-top:6px">
  <div class="col">
    <div class="label">Ukuran Martin Strobo</div>
    <input id="martinScale" type="range" min="0.5" max="2" step="0.1" value="1">
  </div>
  <div class="col">
    <div class="label">Rotasi Martin Strobo (°)</div>
    <input id="martinRotate" type="range" min="-180" max="180" step="5" value="0">
  </div>
</div>
    <div style="margin-top:8px" class="row">
      <div class="col">
        <div class="label">Ukuran Wallwasher</div>
        <input id="wallScale" type="range" min="0.5" max="2" step="0.1" value="1">
      </div>
      <div class="col">
        <div class="label">Rotasi Wallwasher (°)</div>
        <input id="wallRotate" type="range" min="-180" max="180" step="5" value="0">
      </div>
<input type="color" id="goboColor1" value="#ff00ff">
<input type="color" id="goboColor2" value="#ffffff">
<input type="color" id="goboColor3" value="#ff66ff">
    </div>
  <button id="goboColorBtn">GOBO COLOR OFF</button>
    <div class="label">Cross Color Custom</div>
<div class="row">
  <div class="col">
    <label>Warna 1</label>
    <input type="color" id="colorA" value="#ffffff">
  </div>
  <div class="col">
    <label>Warna 2</label>
    <input type="color" id="colorB" value="#b300ff">
  </div>
</div>
<div class="row" style="margin-top:5px;">
  <div class="col">
    <label>Speed (detik)</label>
    <input id="crossSpeed" type="range" min="0.2" max="5" step="0.1" value="1">
    <div class="small">Pergantian: <span id="crossSpeedLabel">1.0</span>s</div>
  </div>
 </div>
  <div class="row" style="margin-top:6px">
  <div class="col">
    <div class="label">Warna Martin Strobo</div>
    <input id="martinColor" type="color" value="#ffffff" style="width:100%">
  </div>
  <div class="col">
    <div class="label">Mode Warna</div>
    <select id="martinColorMode" style="width:100%">
      <option value="global">Ikut Beam</option>
      <option value="custom">Custom</option>
    </select>
  </div>
</div>
    <div class="footer">GEBER LIGHTING — TEAM GEBER</div>
  </div>
</div>
<script>
/* ========== Core from original (kept mostly intact) ========== */
const canvas = document.getElementById('stage');
const ctx = canvas.getContext('2d');
ctx.imageSmoothingEnabled = true;
ctx.imageSmoothingQuality = "high";
function resizeCanvas(){
  canvas.width = window.innerWidth;
  canvas.height = Math.round(window.innerHeight * 0.6);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();
const ui = {
  powerBtn: document.getElementById('powerBtn'),
  beamCount: document.getElementById('beamCount'),
  beamCountLabel: document.getElementById('beamCountLabel'),
  dimmer: document.getElementById('dimmer'),
  beamAngle: document.getElementById('beamAngle'),
  beamRange: document.getElementById('beamRange'),
  globalColor: document.getElementById('globalColor'),
  rainbowBtn: document.getElementById('rainbowBtn'),
  goboBtn: document.getElementById('goboBtn'),
  prismaRotate: document.getElementById('prismaRotate'),
  strobeSpeed: document.getElementById('strobeSpeed'),
  autoPresets: document.getElementById('autoPresets'),
  modeSelect: document.getElementById('modeSelect'),
  manualArea: document.getElementById('manualArea'),
  manualHeadSelect: document.getElementById('manualHeadSelect'),
  manualPan: document.getElementById('manualPan'),
  manualTilt: document.getElementById('manualTilt'),
  manualColor: document.getElementById('manualColor'),
  saveHeadA: document.getElementById('saveHeadA'),
  loadHeadA: document.getElementById('loadHeadA'),
  saveHeadB: document.getElementById('saveHeadB'),
  loadHeadB: document.getElementById('loadHeadB'),
  saveAll: document.getElementById('saveAll'),
  loadAll: document.getElementById('loadAll'),
  clearSlots: document.getElementById('clearSlots'),
  chaseControls: document.getElementById('chaseControls'),
  wallCount: document.getElementById('wallCount'),
  wallCountLabel: document.getElementById('wallCountLabel'),
  spawnWall: document.getElementById('spawnWall'),
  clearWall: document.getElementById('clearWall'),
  parCount: document.getElementById('parCount'),
  parCountLabel: document.getElementById('parCountLabel'),
  spawnPar: document.getElementById('spawnPar'),
  clearPar: document.getElementById('clearPar'),
  wallScale: document.getElementById('wallScale'),
  wallRotate: document.getElementById('wallRotate'),
  martinScale: document.getElementById('martinScale'),
  martinRotate: document.getElementById('martinRotate'),
  martinCount: document.getElementById("martinCount"),
  martinCountLabel: document.getElementById("martinCountLabel"),
  spawnMartin: document.getElementById("spawnMartin"),
  clearMartin: document.getElementById("clearMartin"),
  martinColor: document.getElementById("martinColor"),
  martinColorMode: document.getElementById("martinColorMode"),
  tronVideoFile: document.getElementById("tronVideoFile"),
  playTron: document.getElementById("playTron"),
  pauseTron: document.getElementById("pauseTron"),
  clearTron: document.getElementById("clearTron"),
  goboColorBtn: document.getElementById('goboColorBtn'),
  goboColor1: document.getElementById('goboColor1'),
  goboColor2: document.getElementById('goboColor2'),
  goboColor3: document.getElementById('goboColor3'),
  crossColorBtn: document.getElementById("crossColorBtn"),
  colorA: document.getElementById("colorA"),
  colorB: document.getElementById("colorB"),
  crossSpeed: document.getElementById("crossSpeed"),
  crossSpeedLabel: document.getElementById("crossSpeedLabel"),
  presetSpeed: document.getElementById('presetSpeed'),
  miniBruteToggle: document.getElementById('miniBruteToggle')
};
const PRESET_THRESHOLD = 95;
const SMOOTH = 0.12;
let strobeAccum = 0;
const state = {
  power: true,
  presetSpeed: 1.0,
  dimmer: Number(ui.dimmer ? ui.dimmer.value : 95)/100,
  angle: Number(ui.beamAngle ? ui.beamAngle.value : 12),
  range: Number(ui.beamRange ? ui.beamRange.value : 900),
  globalColor: ui.globalColor ? ui.globalColor.value : '#ffffff',
  rainbow: false,
  gobo: false,
  strobeMode: 'off',
  strobeSpeed: Number(ui.strobeSpeed ? ui.strobeSpeed.value : 14),
  prismaMode: 'none',
  prismaRotate: false,
  time: 0,
  presetActive: new Array(13).fill(false),
  heads: [],
  manualSelected: 0,
  miniBruteOn: false,
  bruteIntensity: 1.0,
  chases: [null,null,null,null,null],
  wallwashers: [],
  parleds: [],
  bgImageCanvas: null,
  miniBrutePos: { x: null, y: null },
  miniBrutes: [],
  martins: [],
  dragTarget: null,
  dragging: false,
  dragOffset: {x:0, y:0},
  selectedHead: null,
  selectedWall: null,
  selectedMartin: null,
  crossColor: false,
  goboColorFx: false,
  goboColors: ['#ff00ff', '#ffffff', '#ff66ff'],
  goboColorShift: 0,
  martinColorMode: 'global'
};
function withAlpha(color, alpha){
  if(!color) color = '#ffffff';
  color = String(color).trim();
  const hslMatch = color.match(/^hsl\(\s*([^\)]+)\s*\)$/i);
  if(hslMatch){ return `hsla(${hslMatch[1].trim()}, ${alpha})`; }
  if(/^hsla?\(/i.test(color) || /^rgba?\(/i.test(color)){
    const inner = color.replace(/^[^\(]+\(/,'').replace(/\)$/, '');
    const parts = inner.split(',').map(s=>s.trim());
    const baseParts = parts.slice(0,3).join(', ');
    if(/^hsl/i.test(color)){
      return `hsla(${parts[0]}, ${parts[1]}, ${parts[2]}, ${alpha})`;
    } else {
      return `rgba(${parts[0]}, ${parts[1]}, ${parts[2]}, ${alpha})`;
    }
  }
  const rgbMatch = color.match(/^rgb\(\s*([^\)]+)\s*\)$/i);
  if(rgbMatch){ return `rgba(${rgbMatch[1].trim()}, ${alpha})`; }
  const hexMatch = color.match(/^#([0-9a-f]{3}|[0-9a-f]{6})$/i);
  if(hexMatch){
    let hex = hexMatch[1];
    if(hex.length === 3) hex = hex.split('').map(ch=>ch+ch).join('');
    const r = parseInt(hex.slice(0,2),16);
    const g = parseInt(hex.slice(2,4),16);
    const b = parseInt(hex.slice(4,6),16);
    return `rgba(${r}, ${g}, ${b}, ${alpha})`;
  }
  return `rgba(255,255,255,${alpha})`;
}
function colorStop(color, a){ return withAlpha(color, a); }
function lerp(a,b,f){ return a + (b-a)*f; }
function clamp(v,a,b){ return Math.max(a, Math.min(b, v)); }
function initHeads(count=8){
  ui.beamCountLabel.textContent = String(count);
  state.heads = [];
  const trY = Math.round(canvas.height * 0.12);
  const margin = Math.min(80, canvas.width * 0.06);
  const usable = canvas.width - margin*2;
  const spacing = count > 1 ? usable / (count - 1) : 0;
  for(let i=0;i<count;i++){
    const x = Math.round(margin + i*spacing);
    const pan = (i - (count-1)/2) * 8;
    const tilt = -12;
    state.heads.push({
      id: i, x, y: trY, pan, tilt, targetPan: pan, targetTilt: tilt,
      color: '#ffffff', intensity: state.dimmer, angle: state.angle, range: state.range, prismRotation: 0
    });
  }
  buildManualSelect();
  buildPresetsUI();
}
initHeads(Number(ui.beamCount ? ui.beamCount.value : 8));
function presetName(i){ 
  return ['Pargoy1','Pargoy2','Fan','Circle','SlowTilt','Circle2','Spiral','Pargoy terbaru','GTW','ZigZag','ZigZag2','Zigzag3','Circle3'][i] || `P${i+1}`; 
}
function buildPresetsUI(){
  ui.autoPresets.innerHTML = '';
  for(let i=0;i<13;i++){
    const box = document.createElement('div'); box.className='presetBox';
    const f = document.createElement('input'); f.type='range'; f.min=0; f.max=100; f.value=0; f.dataset.id=i; f.className='presetFader';
    const lbl = document.createElement('div'); lbl.className='small'; lbl.textContent = `P${i+1} ${presetName(i)}`;
    f.addEventListener('input', (e)=>{
      const id = Number(e.target.dataset.id), v = Number(e.target.value);
      const prev = state.presetActive[id];
      state.presetActive[id] = v >= PRESET_THRESHOLD;
      if(state.presetActive[id] && !prev) setStatus(`Preset ${id+1} ON`);
      if(!state.presetActive[id] && prev) setStatus(`Preset ${id+1} OFF`);
    });
    box.appendChild(f); box.appendChild(lbl); ui.autoPresets.appendChild(box);
  }
}
function buildManualSelect(){
  ui.manualHeadSelect.innerHTML = '';
  for(const h of state.heads){
    const o = document.createElement('option'); o.value = h.id; o.textContent = `Head ${h.id+1}`; ui.manualHeadSelect.appendChild(o);
  }
  ui.manualHeadSelect.value = state.manualSelected;
}
function updateManualControls(id){
  const h = state.heads.find(x=>x.id === Number(id));
  if(!h) return;
  ui.manualPan.value = Math.round(h.pan);
  ui.manualTilt.value = Math.round(h.tilt);
  ui.manualColor.value = h.color || '#ffffff';
}
function presetOffset(p, t, i) {
  const speed = state.presetSpeed || 1.0;
  const mid = (state.heads.length - 1) / 2;
  const dist = Math.abs(i - mid);
  switch (p) {
    case 0: {
      const panSpeed = 0.7;
      const pan = Math.sin(t * panSpeed * speed + i * 0.28) * 48;
      const tiltBase = -12;
      const tiltSpeed = 2.6 + (1 - dist / (mid || 1)) * 1.6;
      const s = Math.sin(t * tiltSpeed * speed + i * 0.6);
      const amp = 20;
      const tilt = tiltBase + (Math.sign(s) * (6 + Math.abs(s) * amp)) * -1;
      return { pan, tilt };
    }
    case 1: {
      const sp = 5.0;
      const pan = Math.sign(Math.sin(t * sp * speed + i * 0.4)) * 56;
      const tilt = -12 + Math.cos(t * 0.7 * speed + i * 0.3) * -4;
      return { pan, tilt };
    }
    case 2: {
      const spread = Math.sin(t * 0.7 * speed) * 26;
      const pan = (i - mid) * spread / ((state.heads.length / 2) || 1);
      const tilt = -10 + Math.cos(t * 0.9 * speed + i * 0.2) * -6;
      return { pan, tilt };
    }
    case 3: {
      const spd = 1.0 + dist * 0.04;
      const ang = t * 2.3 * spd * speed + i * (Math.PI * 2 / state.heads.length);
      return { pan: Math.sin(ang) * 28, tilt: -12 + Math.cos(ang) * 8 };
    }
    case 4: {
  // === Circle Delay Bertahap (beam makin belakang makin telat) ===
  const speed = state.presetSpeed || 1.0;
  const panAmp = 32;     // lebar gerak kanan-kiri
  const tiltAmp = 32;    // tinggi naik-turun
  const baseTilt = -7;  // posisi dasar tilt
  // semakin tinggi index beam, makin delay
  const delay = i * 0.4;  // ubah 0.5 untuk jarak antar beam
  const ang = (state.time * 1.6 * speed) - delay;
  const pan = Math.sin(ang) * panAmp;
  const tilt = baseTilt + Math.cos(ang) * tiltAmp;
  return { pan, tilt };
}
    case 5: {
      const s = 0.9 + (i % 3) * 0.25;
      const pan = Math.sin(t * 1.6 * s * speed + i * 0.3) * (10 + (i % 3) * 6);
      const tilt = -10 + Math.cos(t * 0.4 * speed + i * 0.3) * -8;
      return { pan, tilt };
    }
    case 6: {
      const spd = 1.4 * (1 + (1 - dist / (mid || 1)) * 0.7);
      const ang = t * spd * speed + i * 0.45;
      const radius = 6 + (mid - dist) * 3;
      return { pan: Math.sin(ang) * radius * 2.2, tilt: -12 + Math.sin(t * 1.6 * speed + i * 0.6) * -14 };
    }
    case 7: {
  // --- Pargoy Bumerang V2 (lebih cepat naik-turun, kanan-kiri lambat) ---
  const ampPan = 38;        // gerak kanan-kiri (lebar tapi lambat)
  const ampTilt = 10;       // naik-turun lebih tinggi dari sebelumnya
  const panSpeed = 0.9 * speed;   // kanan-kiri lambat
  const tiltSpeed = 6.2 * speed;  // naik-turun cepat
  const panMod = 0.9 + 0.12 * Math.sin(t * 0.36 * speed);
  const pan = Math.sin(t * panSpeed) * ampPan * panMod;
  const tilt = -12 + Math.sin(t * tiltSpeed) * ampTilt;
  return { pan, tilt };
}
case 8: {
  const total = state.heads.length;
  const mid = (total - 1) / 2;
  const basePan = (i - mid) * 10;
  const upTilt = -12;               
  const downTilt = 40;              
  const speed = (state.presetSpeed && Number(state.presetSpeed)) || 1.0;
  const moveDur = 0.5 / speed;      
  const waitAll = 0.6 / speed;      
  const totalCycle = (moveDur * total * 2) + (waitAll * 2);
  let tt = (t * 1) % totalCycle;
  let pan = basePan;
  let tilt = upTilt;
  if (tt < moveDur * total + waitAll) {
    const start = i * moveDur;
    const end = start + moveDur;
    if (tt >= start && tt < end) {
      const f = (tt - start) / moveDur;
      tilt = lerp(upTilt, downTilt, f);
      pan = lerp(basePan, 0, f);
    } else if (tt >= end) {
      tilt = downTilt;
      pan = 0;
    } else {
      tilt = upTilt;
      pan = basePan;
    }
  }
  else {
    const tt2 = tt - (moveDur * total + waitAll);
    const start = i * moveDur;
    const end = start + moveDur;
    if (tt2 >= start && tt2 < end) {
      const f = (tt2 - start) / moveDur;
      tilt = lerp(downTilt, upTilt, f);
      pan = lerp(0, basePan, f);
    } else if (tt2 >= end) {
      tilt = upTilt;
      pan = basePan;
    } else {
      tilt = downTilt;
      pan = 0;
    }
  }
  return { pan, tilt };
}
case 9: {
  // === Zigzag Opposite + Naik Turun Serempak ===
  const speed = state.presetSpeed || 1.0;
  const panAmp = 40;        // seberapa lebar kanan-kiri
  const tiltAmp = 17;       // seberapa tinggi naik-turun
  const panSpeed = 2.8 * speed;   // kecepatan kanan-kiri
  const tiltSpeed = 0.5 * speed;  // naik-turun lebih lambat
  const phase = (i % 2 === 0) ? 0 : Math.PI; // tiap beam berlawanan arah
  const pan = Math.sin(state.time * panSpeed + phase) * panAmp;
  // semua naik-turun bareng, tidak pakai phase
  const tilt = -12 + Math.sin(state.time * tiltSpeed) * tiltAmp;
  return { pan, tilt };
}
case 10: {
  // === Zigzag Terbalik: Kanan-kiri bareng, Naik-turun berlawanan ===
  const speed = state.presetSpeed || 1.0;
  const panAmp = 40;        // lebar kanan-kiri
  const tiltAmp = 20;       // tinggi naik-turun
  const panSpeed = 0.5 * speed;   // kanan-kiri pelan
  const tiltSpeed = 2.8 * speed;  // naik-turun agak cepat biar hidup
  // semua beam gerak kanan-kiri bareng
  const pan = Math.sin(state.time * panSpeed) * panAmp;
  // tiap beam naik-turun berlawanan arah
  const phase = (i % 2 === 0) ? 0 : Math.PI;
  const tilt = -12 + Math.sin(state.time * tiltSpeed + phase) * tiltAmp;
  return { pan, tilt };
}
case 11: {
  // === Zigzag Terbalik: Kanan-kiri bareng, Naik-turun berlawanan ===
  const speed = state.presetSpeed || 1.0;
  const panAmp = 40;        // lebar kanan-kiri
  const tiltAmp = 8;       // tinggi naik-turun
  const panSpeed = 0.7 * speed;   // kanan-kiri pelan
  const tiltSpeed = 5.8 * speed;  // naik-turun agak cepat biar hidup
  // semua beam gerak kanan-kiri bareng
  const pan = Math.sin(state.time * panSpeed) * panAmp;
  // tiap beam naik-turun berlawanan arah
  const phase = (i % 2 === 0) ? 0 : Math.PI;
  const tilt = -11 + Math.sin(state.time * tiltSpeed + phase) * tiltAmp;
  return { pan, tilt };
}
case 12: {
  // === Circle Bolak-Balik Separuh Kanan-Kiri Delay (Simetris) ===
  const speed = state.presetSpeed || 1.0;
  const panAmp = 32;     // lebar kanan-kiri
  const tiltAmp = 40;    // tinggi naik-turun
  const baseTilt = -12;  // posisi dasar tilt
  const total = state.heads.length;
  const half = total / 2;          // pembagi antara kiri & kanan
  const delayAmount = 0.35;        // besar delay antar beam
  // Normalisasi index agar kedua sisi punya skala delay 0..(half-1)
  const localIndex = (i < half) ? i : (i - half);
  const dir = (i < half) ? 1 : -1; // separuh pertama ke kanan, separuh kedua ke kiri
  // delay simetris (kiri & kanan punya nilai sama untuk posisi relatif yang sama)
  const delay = localIndex * delayAmount;
  // gerakan bolak-balik halus
  const swing = Math.sin(state.time * 0.6 * speed);
  const ang = dir * swing * Math.PI - delay;
  const pan = Math.sin(ang) * panAmp;
  const tilt = baseTilt + Math.cos(ang) * tiltAmp;
  return { pan, tilt };
}
case 13: {
  // ===  Circle Spread Delay (efek seperti di video: kipas menyebar bolak-balik) ===
  const speed = state.presetSpeed || 1.0;
  const panAmp = 40;     // seberapa lebar gerakan kanan-kiri
  const tiltAmp = 8;     // sedikit gerakan naik-turun biar hidup
  const baseTilt = -12;
  const total = state.heads.length;
  const delayAmount = 0.35; // semakin besar -> jeda antar beam makin kelihatan
  // setiap beam delay makin besar, jadi menyebar dari tengah ke luar
  const delay = i * delayAmount;
  // sudut bolak-balik halus
  const swing = Math.sin(state.time * 0.7 * speed); // gerak kanan–kiri
  const ang = swing * Math.PI - delay;
  const pan = Math.sin(ang) * panAmp;
  const tilt = baseTilt + Math.cos(ang) * tiltAmp;
  return { pan, tilt };
}
  }
}
function drawBackground(){
  ctx.fillStyle = '#000'; ctx.fillRect(0,0,canvas.width,canvas.height);
  if(state.bgImageCanvas){
    const size = canvas.width;
    const yoffset = Math.max(0, Math.round((canvas.height - size) / 2));
    ctx.drawImage(state.bgImageCanvas, 0, 0, state.bgImageCanvas.width, state.bgImageCanvas.height, 0, yoffset, canvas.width, size);
    ctx.fillStyle = 'rgba(0,0,0,0.18)'; ctx.fillRect(0, yoffset, canvas.width, size);
  }
  ctx.fillStyle = '#041017'; ctx.fillRect(0, canvas.height*0.82, canvas.width, canvas.height*0.18);
  const tY = canvas.height*0.12; ctx.fillStyle = '#111217'; ctx.fillRect(0, tY-10, canvas.width, 14);
}
function drawHeadMounts(){
  const trY = canvas.height*0.12;
  for(const h of state.heads){
    ctx.fillStyle = '#23282c'; ctx.fillRect(h.x-12, trY-26, 24, 12);
    ctx.strokeStyle = 'rgba(255,255,255,0.03)'; ctx.strokeRect(h.x-12, trY-26, 24, 12);
  }
}
function drawHeadMarkers(){
  for(const h of state.heads){
    ctx.beginPath(); ctx.arc(h.x,h.y,12,0,Math.PI*2); ctx.fillStyle='#0b0e11'; ctx.fill();
    const fillColor = state.rainbow ? `hsl(${Math.round((state.time*60 + h.id*28) % 360)},100%,60%)` : (h.color || state.globalColor || '#9fb0c4');
    ctx.beginPath(); ctx.arc(h.x,h.y,6,0,Math.PI*2); ctx.fillStyle = fillColor; ctx.fill();
    if(state.selectedHead === h.id){ ctx.strokeStyle='rgba(0,212,255,0.95)'; ctx.lineWidth=2; ctx.beginPath(); ctx.arc(h.x,h.y,18,0,Math.PI*2); ctx.stroke(); }
  }
}
function computeEndpoint(h, panDeg, tiltDeg, scale, angleDeg){
  const pR = panDeg * Math.PI/180;
  const tR = tiltDeg * Math.PI/180;
  const dx = Math.sin(pR) * Math.cos(tR); 
  const dy = -Math.sin(tR);
  const dz = Math.cos(pR) * Math.cos(tR); 
  const lenBase = Number(h.range || state.range);
  const len = lenBase * scale * (1 - Math.abs(Math.sin(tR)) * 0.18); 
  const endX = h.x + dx * len;
  const endY = h.y + dy * len;
  const spread = Math.tan(angleDeg * Math.PI/180) * len;
  return { endX, endY, spread };
}
function drawBeam(h){
  if(state.miniBruteOn) return;
  const baseX = h.x, baseY = h.y;
  const angle = h.angle || state.angle;
  const layers = [
    {scale:0.92,alpha:1.0},
    {scale:1.12,alpha:0.36},
    {scale:1.45,alpha:0.12},
    {scale:1.9,alpha:0.06}
  ];
  const computedColor = state.rainbow
    ? `hsl(${Math.round((state.time * 60 + h.id*28) % 360)},100%,60%)`
    : (h.color || state.globalColor || '#ffffff');
   // === fungsi pembuat beam utama ===
  function drawCone(scale, alpha, panOffset=0){
    const e = computeEndpoint(h, h.pan + panOffset, h.tilt, scale, angle);

    const grad = ctx.createLinearGradient(baseX, baseY, e.endX, e.endY);
    if (state.goboColorFx) {
      const c1 = state.goboColors[0];
      const c2 = state.goboColors[1];
      const c3 = state.goboColors[2];
      const s = state.goboColorShift;
      grad.addColorStop((0.0 + s) % 1, colorStop(c1, state.dimmer * alpha));
      grad.addColorStop((0.25 + s) % 1, colorStop(c2, state.dimmer * alpha));
      grad.addColorStop((0.55 + s) % 1, colorStop(c3, state.dimmer * alpha));
      grad.addColorStop((0.85 + s) % 1, 'rgba(0,0,0,0)');
    } else {
      grad.addColorStop(0, colorStop(computedColor, state.dimmer * alpha));
      grad.addColorStop(0.5, colorStop(computedColor, state.dimmer * alpha * 0.12));
      grad.addColorStop(1, 'rgba(0,0,0,0)');
    }

    ctx.beginPath();
    ctx.moveTo(baseX, baseY);
    ctx.lineTo(e.endX - e.spread * 0.6, e.endY);
    ctx.lineTo(e.endX + e.spread * 0.6, e.endY);
    ctx.closePath();
    ctx.globalCompositeOperation = 'lighter';
    ctx.fillStyle = grad;
    ctx.fill();
    ctx.globalCompositeOperation = 'source-over';
  }
  drawCone(layers[0].scale, layers[0].alpha);
  const pm = state.prismaMode;
  if(pm.startsWith('split')){
    const n = Number(pm.replace('split','')) || 3;
    const spreadDeg = 14;
    const rot = state.prismaRotate ? (h.prismRotation || 0) : 0;
    for(let k=0;k<n;k++){
      const frac = n===1?0.5:k/(n-1);
      const offDeg = (frac - 0.5) * spreadDeg + rot;
      drawCone(1.06, 0.28, offDeg);
    }
    drawCone(1.12, 0.22);
    drawCone(1.45, 0.08);
  } else if(pm === 'linear'){
    for(let k=0;k<4;k++){
      const off = (k - (4-1)/2) * 10;
      drawCone(1 + Math.abs(off)/50, 0.26, off);
    }
  } else if(pm === 'combo'){
    for(let k=0;k<3;k++) drawCone(1 + k*0.06, 0.22);
    const rot = state.prismaRotate ? (h.prismRotation || 0) : 0;
    for(let p=0;p<4;p++) drawCone(1.1 + p*0.05, 0.16, rot + p*2);
  }
  drawCone(layers[3].scale, layers[3].alpha);
  if(state.gobo){
    const e = computeEndpoint(h, h.pan, h.tilt, 0.85, angle);
    ctx.save();
    ctx.globalAlpha = 0.28 * state.dimmer;
    ctx.translate(e.endX, e.endY);
    ctx.rotate((state.time*0.4 + h.id*0.35) % (Math.PI*2));
    const aur = ctx.createRadialGradient(0,0,0,0,0,
      Math.max(60, Math.tan(angle * Math.PI/180) * (h.range||state.range) * 0.55));
    aur.addColorStop(0, 'rgba(120,220,255,0.45)');
    aur.addColorStop(0.45, 'rgba(220,120,255,0.28)');
    aur.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = aur;
    ctx.beginPath();
    ctx.ellipse(0,0,(h.range||state.range)*0.06,(h.range||state.range)*0.04,0,0,Math.PI*2);
    ctx.fill();
    ctx.restore();
  }
  const ep = computeEndpoint(h, h.pan, h.tilt, 0.95, angle);
  const radius = 10 + (h.intensity||1) * 8;
  const spotGrad = ctx.createRadialGradient(ep.endX, ep.endY, 0, ep.endX, ep.endY, radius);
  spotGrad.addColorStop(0, colorStop(computedColor, 0.36 * state.dimmer));
  spotGrad.addColorStop(1, 'rgba(0,0,0,0)');
  ctx.globalCompositeOperation = 'lighter';
  ctx.fillStyle = spotGrad;
  ctx.fillRect(ep.endX - radius, ep.endY - radius, radius*2, radius*2);
  ctx.globalCompositeOperation = 'source-over';
}
function drawMiniBrutes(){
  if(!state.miniBruteOn) return;
  if(!state.miniBrutes || state.miniBrutes.length === 0) return;
  for(let i=0; i<state.miniBrutes.length; i++){
    const mb = state.miniBrutes[i];
    const size = Math.min(64, Math.round(canvas.width * 0.06));
    const cx = mb.x, cy = mb.y;
    const hw = size * 1.6, hh = size * 0.95;
    const hx = cx - hw/2, hy = cy - hh/2;
    ctx.fillStyle = 'rgba(14,14,16,0.95)';
    ctx.fillRect(hx, hy, hw, hh);
    const gap = 6;
    const lampSize = Math.round(Math.min(hw, hh) / 2.6);
    const startX = hx + (hw - (lampSize*2 + gap))/2;
    const startY = hy + (hh - (lampSize*2 + gap))/2;
    for(let r=0; r<2; r++){
      for(let c=0; c<2; c++){
        const x = startX + c*(lampSize + gap) + lampSize/2;
        const y = startY + r*(lampSize + gap) + lampSize/2;
        const visible = strobeVisible(1000 + i);
        if(visible){
          const g = ctx.createRadialGradient(x, y, 0, x, y, lampSize * 1.3);
          g.addColorStop(0, 'rgba(255,255,240,1)');
          g.addColorStop(0.4, 'rgba(255,240,200,0.7)');
          g.addColorStop(1, 'rgba(255,200,120,0)');
          ctx.globalCompositeOperation = 'lighter';
          ctx.fillStyle = g;
          ctx.beginPath();
          ctx.arc(x, y, lampSize * 1.1, 0, Math.PI * 2);
          ctx.fill();
          ctx.globalCompositeOperation = 'source-over';
        }
        ctx.beginPath();
        ctx.arc(x, y, lampSize * 0.25, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255,255,255,0.9)';
        ctx.fill();
      }
    }
  }
}
function strobeVisible(index){
  const mode = state.strobeMode;
  const speed = clamp(Number(state.strobeSpeed), 0.5, 200);
  if(mode === 'off' || !state.power) return true;
  if(mode === 'blink') return Math.floor(strobeAccum * speed) % 2 === 0;
  if(mode === 'flow'){ const phase = (strobeAccum * speed * 2 * Math.PI) + (index * 0.6); return Math.sin(phase) > 0; }
  if(mode === 'random'){ const v = Math.sin((strobeAccum * speed * 3.14) + index * 7.13); return v > Math.cos(index * 0.3); }
  const totalHeads = state.heads.length;
  if(mode === 'alternate'){
    const group = index % 2;
    const timeStep = Math.floor(strobeAccum * speed);
    return timeStep % 2 === group;
  }
  if(mode === 'chase'){
    const timeStep = Math.floor(strobeAccum * speed * 2) % totalHeads;
    return index === timeStep;
  }
  if(mode === 'converge'){
    const midPoint = Math.floor(totalHeads / 2);
    const timeStep = Math.floor(strobeAccum * speed * 2) % midPoint;
    return index === timeStep || index === (totalHeads - 1 - timeStep);
  }
  if (mode === 'split') {
    const half = Math.floor(totalHeads / 2);
    const phase = Math.floor(strobeAccum * speed * 2) % 2;
    if (phase === 0) return index < half;
    else return index >= half;
  }
  return true;
}
function spawnWallwashers(count){
  state.wallwashers = [];
  const margin = 40;
  const usable = canvas.width - margin*2;
  const spacing = count > 1 ? usable / (count - 1) : 0;
  const baseY = Math.round(canvas.height * 0.55);
  for(let i=0;i<count;i++){
    const x = Math.round(margin + i*spacing);
    const w = { id:i, x, y: baseY, rotation:0, scale:1, ledCount: 12, color: '#ffffff', intensity: state.dimmer };
    state.wallwashers.push(w);
  }
  saveStateUI();
}
function drawWallwashers(){
  for(let i=0;i<state.wallwashers.length;i++){
    const w = state.wallwashers[i];
    const barH = Math.round(canvas.height * 0.36);
    const barW = Math.max(18, Math.round(canvas.width * 0.02));
    const top = w.y - Math.round(barH/2);
    ctx.save();
    ctx.translate(w.x, top + barH/2);
    ctx.rotate((w.rotation||0) * Math.PI/180);
    ctx.scale(w.scale || 1, w.scale || 1);
    ctx.fillStyle = '#0b0f11'; ctx.fillRect(-Math.round(barW/2), -Math.round(barH/2), barW, barH);
    ctx.strokeStyle = 'rgba(255,255,255,0.04)'; ctx.strokeRect(-Math.round(barW/2), -Math.round(barH/2), barW, barH);
    const ledCols = 2;
    const ledRows = w.ledCount || 12;
    const gap = Math.round((barH - ledRows*8) / Math.max(1, ledRows));
    for(let r=0;r<ledRows;r++){
      const ly = -Math.round(barH/2) + gap/2 + r*(8 + gap) + 8;
      const lx = -Math.round(barW/2) + 8;
      const visible = strobeVisible(i*3 + r);
      const alpha = visible ? clamp(w.intensity, 0.08, 1) : 0.04;
      const ledColor = state.rainbow ? `hsl(${Math.round((state.time*60 + i*22 + r*6) % 360)},100%,60%)` : (w.color || state.globalColor || '#ffffff');
      ctx.beginPath(); ctx.arc(lx, ly, 5, 0, Math.PI*2); ctx.fillStyle = withAlpha(ledColor, alpha); ctx.fill();
      ctx.beginPath(); ctx.arc(lx, ly, 2, 0, Math.PI*2); ctx.fillStyle = withAlpha('#fff', alpha*0.9); ctx.fill();
    }
    const stripW = Math.round(barW * 0.36);
    const stripX = Math.round(barW/2) - stripW - 6;
    const stripGrad = ctx.createLinearGradient(stripX - barW/2, -barH/2, stripX - barW/2, barH/2);
    const color = state.rainbow ? `hsl(${Math.round((state.time*60 + i*40) % 360)},100%,60%)` : (w.color || state.globalColor || '#fff');
    stripGrad.addColorStop(0, withAlpha(color, 0.8 * w.intensity));
    stripGrad.addColorStop(0.5, withAlpha(color, 0.28 * w.intensity));
    stripGrad.addColorStop(1, 'rgba(0,0,0,0)');
    ctx.fillStyle = stripGrad;
    ctx.fillRect(stripX - barW/2, -Math.round(barH/3), stripW, Math.round(barH*2/3));
    ctx.restore();
  }
}
function spawnParleds(count){
  state.parleds = [];
  const margin = 40;
  const usable = canvas.width - margin*2;
  const spacing = count > 1 ? usable / (count - 1) : 0;
  const baseY = Math.round(canvas.height * 0.72);
  for(let i=0;i<count;i++){
    const x = Math.round(margin + i*spacing);
    const p = { id:i, x, y: baseY, ledCount: 7, color: '#ffffff', intensity: state.dimmer };
    state.parleds.push(p);
  }
  saveStateUI();
}
function spawnMiniBrutes(count){
  state.miniBrutes = [];
  const margin = 40;
  const usable = canvas.width - margin * 2;
  const spacing = count > 1 ? usable / (count - 1) : 0;
  const y = Math.round(canvas.height * 0.25);
  for (let i = 0; i < count; i++) {
    state.miniBrutes.push({
      id: i,
      x: Math.round(margin + i * spacing),
      y: y,
      intensity: 1.0
    });
  }
  saveStateUI();
}
function drawParleds(){
  for(let i=0;i<state.parleds.length;i++){
    const p = state.parleds[i];
    const radius = Math.max(18, Math.round(canvas.width * 0.03));
    ctx.beginPath(); ctx.arc(p.x, p.y, radius, 0, Math.PI*2); ctx.fillStyle = '#0b0f10'; ctx.fill();
    ctx.strokeStyle = 'rgba(255,255,255,0.04)'; ctx.stroke();
    const n = p.ledCount || 7;
    for(let k=0;k<n;k++){
      const ang = (k / n) * Math.PI*2 - Math.PI/2;
      const lx = p.x + Math.cos(ang) * (radius*0.6);
      const ly = p.y + Math.sin(ang) * (radius*0.6);
      const visible = strobeVisible(200 + i*7 + k);
      const alpha = visible ? clamp(p.intensity, 0.08, 1) : 0.05;
      const ledColor = state.rainbow ? `hsl(${Math.round((state.time*60 + i*28 + k*8) % 360)},100%,60%)` : (p.color || state.globalColor || '#ffffff');
      const g = ctx.createRadialGradient(lx,ly,0,lx,ly,8);
      g.addColorStop(0, withAlpha('#fff', alpha));
      g.addColorStop(0.2, withAlpha(ledColor, alpha));
      g.addColorStop(1, 'rgba(0,0,0,0)');
      ctx.fillStyle = g;
      ctx.beginPath(); ctx.arc(lx, ly, 6, 0, Math.PI*2); ctx.fill();
    }
  }
}
function spawnMartins(count) {
  state.martins = [];
  const margin = 40;
  const usable = canvas.width - margin * 2;
  const spacing = count > 1 ? usable / (count - 1) : 0;
  const y = Math.round(canvas.height * 0.30);
  for (let i = 0; i < count; i++) {
    state.martins.push({
      id: i,
      x: Math.round(margin + i * spacing),
      y: y,
      rotation: 0,
      scale: 1,
      color: "#ffffff",
      intensity: 1.0
    });
  }
  saveStateUI();
}
// Pastikan video sudah di-load di atas
const martinVideo = document.createElement("video");
martinVideo.src = "https://files.catbox.moe/l2zqlc.mp4";
martinVideo.loop = true;
martinVideo.muted = true;
martinVideo.playsInline= true;
martinVideo.autoplay = true;
martinVideo.play();
function drawMartins() {
  if (!state.martins) return;
  const baseSize = Math.min(100, Math.round(canvas.width * 0.12));
  for (let i = 0; i < state.martins.length; i++) {
    const m = state.martins[i];
    const visible = strobeVisible(300 + i);
    const w = baseSize * 1.6 * (m.scale || 1);
    const h = baseSize * 1.0 * (m.scale || 1);
    ctx.save();
    ctx.translate(m.x, m.y);
    ctx.rotate((m.rotation || 0) * Math.PI / 180);
    ctx.fillStyle = "#111";
    ctx.fillRect(-w / 2, -h / 2, w, h);
    ctx.strokeStyle = "#555";
    ctx.lineWidth = 2;
    ctx.strokeRect(-w / 2, -h / 2, w, h);
    if (visible && state.power) {
      try {
        ctx.drawImage(martinVideo, -w / 2, -h / 2, w, h);
      } catch (err) {}
    }
    ctx.restore();
  }
}
canvas.addEventListener('pointerdown', (e)=>{
  const r = canvas.getBoundingClientRect();
  const px = e.clientX - r.left, py = e.clientY - r.top;
  let nearest = -1, nd = 1e9;
  for(const h of state.heads){
    const d = Math.hypot(px - h.x, py - h.y);
    if(d < 30 && d < nd){ nd=d; nearest=h.id; }
  }
  if(nearest >= 0){
    state.selectedHead = nearest;
    state.dragging = true;
    state.dragTarget = {type:'head', id:nearest};
    const hh = state.heads.find(x=>x.id===nearest);
    state.dragOffset = { x: px - hh.x, y: py - hh.y };
    ui.manualHeadSelect.value = nearest;
    updateManualControls(nearest);
    setStatus('Selected Head '+(nearest+1),700);
    return;
  }
  for(const w of state.wallwashers){
    const barH = Math.round(canvas.height * 0.36);
    const barW = Math.max(18, Math.round(canvas.width * 0.02));
    const left = w.x - Math.round(barW/2);
    const top = w.y - Math.round(barH/2);
    if(px >= left - 8 && px <= left + barW + 8 && py >= top - 8 && py <= top + barH + 8){
      state.dragging = true;
      state.dragTarget = {type:'wall', id: w.id};
      state.dragOffset = { x: px - w.x, y: py - w.y };
      state.selectedWall = w.id;
      ui.wallScale.value = w.scale || 1;
      ui.wallRotate.value = w.rotation || 0;
      setStatus('Selected Wallwasher '+(w.id+1),700);
      return;
    }
  }
  for(const p of state.parleds){
    const radius = Math.max(18, Math.round(canvas.width * 0.03));
    const d = Math.hypot(px - p.x, py - p.y);
    if(d < radius + 8){
      state.dragging = true;
      state.dragTarget = {type:'par', id: p.id};
      state.dragOffset = { x: px - p.x, y: py - p.y };
      setStatus('Selected ParLED '+(p.id+1),700);
      return;
    }
  }
  for(const mb of (state.miniBrutes || [])){
    const size = Math.min(64, Math.round(canvas.width * 0.06));
    const hw = size * 1.6, hh = size * 0.95;
    const hx = mb.x - Math.round(hw/2), hy = mb.y - Math.round(hh/2);
    if(px >= hx && px <= hx + hw && py >= hy && py <= hy + hh){
      state.dragging = true;
      state.dragTarget = {type:'miniBrute', id: mb.id};
      state.dragOffset = { x: px - mb.x, y: py - mb.y };
      setStatus('Selected MiniBrute '+(mb.id+1),700);
      return;
    }
  }
  for (const m of (state.martins || [])) {
    const size = Math.min(100, Math.round(canvas.width * 0.12));
    const w = size * 1.6 * (m.scale || 1);
    const h = size * 1.0 * (m.scale || 1);
    const hx = m.x - w / 2, hy = m.y - h / 2;
    if (px >= hx && px <= hx + w && py >= hy && py <= hy + h) {
      state.dragging = true;
      state.dragTarget = { type: "martin", id: m.id };
      state.dragOffset = { x: px - m.x, y: py - m.y };
      state.selectedMartin = m.id;
      ui.martinScale.value = m.scale || 1;
      ui.martinRotate.value = m.rotation || 0;
      ui.martinColor.value = m.color || "#ffffff";
      setStatus("Selected Martin " + (m.id + 1), 700);
      return;
    }
  }
});
canvas.addEventListener('pointermove', (e)=>{
  if(!state.dragging || !state.dragTarget) return;
  const r = canvas.getBoundingClientRect();
  const px = e.clientX - r.left, py = e.clientY - r.top;
  const t = state.dragTarget;
  if(t.type === 'head'){
    const h = state.heads.find(x=>x.id === t.id);
    if(h){
      h.x = Math.max(20, Math.min(canvas.width - 20, Math.round(px - state.dragOffset.x)));
      h.y = Math.max(10, Math.min(canvas.height - 10, Math.round(py - state.dragOffset.y)));
    }
  } 
  else if(t.type === 'wall'){
    const w = state.wallwashers.find(x=>x.id === t.id);
    if(w){
      w.x = Math.max(20, Math.min(canvas.width - 20, Math.round(px - state.dragOffset.x)));
      w.y = Math.max(60, Math.min(canvas.height * 0.85, Math.round(py - state.dragOffset.y)));
      saveStateUI();
    }
  } 
  else if(t.type === 'par'){
    const p = state.parleds.find(x=>x.id === t.id);
    if(p){
      p.x = Math.max(20, Math.min(canvas.width - 20, Math.round(px - state.dragOffset.x)));
      p.y = Math.max(40, Math.min(canvas.height * 0.9, Math.round(py - state.dragOffset.y)));
      saveStateUI();
    }
  } 
  else if(t.type === 'miniBrute'){
    const mb = state.miniBrutes.find(x=>x.id === t.id);
    if(mb){
      mb.x = Math.max(20, Math.min(canvas.width - 20, Math.round(px - state.dragOffset.x)));
      mb.y = Math.max(20, Math.min(canvas.height - 20, Math.round(py - state.dragOffset.y)));
      saveStateUI();
    }
  }
  else if(t.type === 'martin'){
    const m = state.martins.find(x=>x.id === t.id);
    if(m){
      m.x = Math.max(20, Math.min(canvas.width - 20, Math.round(px - state.dragOffset.x)));
      m.y = Math.max(20, Math.min(canvas.height - 20, Math.round(py - state.dragOffset.y)));
      saveStateUI();
    }
  }
});
canvas.addEventListener('pointerup', ()=>{
  state.dragging = false;
  state.dragTarget = null;
});
const STORAGE_KEY = 'geber_light_fix_v2';
function loadStorage(){ try{ return JSON.parse(localStorage.getItem(STORAGE_KEY) || '{}'); }catch(e){ return {}; } }
function saveStorage(obj){ try{ localStorage.setItem(STORAGE_KEY, JSON.stringify(obj)); setStatus('Saved',900);}catch(e){ setStatus('Storage failed',900);} }
function saveStateUI(){
  const st = loadStorage();
  st.wallwashers = state.wallwashers;
  st.parleds = state.parleds;
  st.miniBrutes = state.miniBrutes;
  saveStorage(st);
}
function restoreStateUI(){
  const st = loadStorage();
  if(st.wallwashers) state.wallwashers = st.wallwashers;
  if(st.parleds) state.parleds = st.parleds;
  if(st.miniBrutes) state.miniBrutes = st.miniBrutes;
}
restoreStateUI();
function createChaseUI(){
  ui.chaseControls.innerHTML = '';
  for(let i=0;i<5;i++){
    const w = document.createElement('div'); w.style.display='flex'; w.style.flexDirection='column'; w.style.gap='6px';
    const t = document.createElement('div'); t.className='small'; t.textContent='Chase '+(i+1);
    const row = document.createElement('div'); row.style.display='flex'; row.style.gap='6px';
    const rec = document.createElement('button'); rec.textContent='REC'; rec.dataset.slot=i; rec.style.background='#8b1a1a';
    const play = document.createElement('button'); play.textContent='PLAY'; play.dataset.slot=i;
    const clr = document.createElement('button'); clr.textContent='CLEAR'; clr.dataset.slot=i;
    row.appendChild(rec); row.appendChild(play); row.appendChild(clr);
    w.appendChild(t); w.appendChild(row); ui.chaseControls.appendChild(w);
    let recorder = null;
    rec.addEventListener('click', ()=>{
      const s = Number(rec.dataset.slot);
      if(rec.dataset.rec === '1'){ rec.dataset.rec='0'; rec.style.background=''; if(recorder){ recorder.stop(); recorder=null; setStatus('Recording stopped',900); } }
      else { rec.dataset.rec='1'; rec.style.background='#d33'; recorder = startRecorder(s, rec); setStatus('Recording chase '+(s+1),900); }
    });
    play.addEventListener('click', ()=> playChaseSlot(Number(play.dataset.slot)));
    clr.addEventListener('click', ()=> clearChaseSlot(Number(clr.dataset.slot)));
  }
}
createChaseUI();
function startRecorder(slot, btn){
  const frames = [];
  const fps = 20;
  const interval = 1000 / fps;
  let running = true;
  const t0 = performance.now();
  function sample(){
    if(!running) return;
    const t = Math.round(performance.now() - t0);
    const snap = state.heads.map(h=>({pan: h.pan, tilt: h.tilt}));
    frames.push({t, heads: snap});
    if(t >= 12000){ stop(); return; }
    setTimeout(sample, interval);
  }
  setTimeout(sample, 0);
  function stop(){
    running = false;
    btn.dataset.rec = '0';
    state.chases[slot] = { frames, fps, ts: Date.now() };
    const st = loadStorage(); st.chases = st.chases || {}; st.chases[slot] = state.chases[slot]; saveStorage(st);
    setStatus('Chase saved to slot '+(slot+1),1200);
  }
  return { stop };
}
function playChaseSlot(slot){
  const chase = state.chases[slot] || (loadStorage().chases && loadStorage().chases[slot]);
  if(!chase || !chase.frames || chase.frames.length===0){ setStatus('Chase empty',800); return; }
  setStatus('Playing chase '+(slot+1),900);
  const frames = chase.frames;
  const start = performance.now();
  function step(){
    const now = performance.now();
    const rel = now - start;
    let idx = 0;
    while(idx < frames.length - 1 && frames[idx+1].t <= rel) idx++;
    const f = frames[Math.min(idx, frames.length-1)];
    if(f){
      for(let i=0;i<state.heads.length;i++){
        const h = state.heads[i];
        const hf = f.heads[i] || f.heads[0] || {pan:h.pan, tilt:h.tilt};
        h.targetPan = hf.pan; h.targetTilt = hf.tilt;
      }
    }
    if(rel >= frames[frames.length-1].t + 40){ setStatus('Chase finished',900); return; }
    requestAnimationFrame(step);
  }
  requestAnimationFrame(step);
}
function clearChaseSlot(slot){ state.chases[slot] = null; const st = loadStorage(); if(st.chases && st.chases[slot]){ delete st.chases[slot]; saveStorage(st); } setStatus('Chase '+(slot+1)+' cleared',900); }
(function loadChases(){ const st = loadStorage(); if(st.chases){ for(let i=0;i<5;i++) if(st.chases[i]) state.chases[i] = st.chases[i]; }})();
let last = performance.now();
function loop(now){
  const dt = Math.min(0.05, (now - last) / 1000); last = now;
  if(state.power) state.time += dt;
  strobeAccum += dt;
  if(ui.dimmer) state.dimmer = Number(ui.dimmer.value)/100;
  if(ui.beamAngle) state.angle = Number(ui.beamAngle.value);
  if(ui.beamRange) state.range = Number(ui.beamRange.value);
  if(ui.globalColor) state.globalColor = ui.globalColor.value;
  if(ui.rainbowBtn) state.rainbow = ui.rainbowBtn.textContent.indexOf('ON') >= 0;
  if(ui.goboBtn) state.gobo = ui.goboBtn.textContent.indexOf('ON') >= 0;
  if(ui.strobeSpeed) state.strobeSpeed = Number(ui.strobeSpeed.value);
  for(let i=0;i<state.heads.length;i++){
    const h = state.heads[i];
    let sumPan=0, sumTilt=0, cnt=0;
    for(let p=0;p<state.presetActive.length;p++){
      if(state.presetActive[p]){ const off = presetOffset(p, state.time, i); sumPan += off.pan; sumTilt += off.tilt; cnt++; }
    }
    if(cnt>0){ h.targetPan = sumPan / cnt; h.targetTilt = sumTilt / cnt; }
    if(ui.modeSelect && ui.modeSelect.value === 'manual' && Number(ui.manualHeadSelect.value) === h.id){
      h.targetPan = Number(ui.manualPan.value);
      h.targetTilt = Number(ui.manualTilt.value);
    }
    h.pan = lerp(h.pan !== undefined ? h.pan : h.targetPan, h.targetPan, SMOOTH);
    h.tilt = lerp(h.tilt !== undefined ? h.tilt : h.targetTilt, h.targetTilt, SMOOTH);
    h.intensity = state.dimmer;
    if(state.prismaRotate){ h.prismRotation = (h.prismRotation || 0) + dt * 60; } else { h.prismRotation = 0; }
    h.angle = state.angle; h.range = state.range;
  }
  drawBackground();
  drawHeadMounts();
  drawWallwashers();
  drawParleds();
  drawMiniBrutes();
  drawMartins();
  for(const h of state.heads){
    if(strobeVisible(h.id)) drawBeam(h);
    updateCrossColor();
    updateGoboColorShift();
  }
  drawHeadMarkers();
  requestAnimationFrame(loop);
}
state.crossColor = false;
let lastCrossChange = performance.now();
let crossColorToggle = false;
if (ui.crossSpeed && ui.crossSpeedLabel) {
  ui.crossSpeed.addEventListener("input", (e) => {
    ui.crossSpeedLabel.textContent = Number(e.target.value).toFixed(1);
  });
}
if (ui.crossColorBtn) {
  ui.crossColorBtn.addEventListener("click", () => {
    state.crossColor = !state.crossColor;
    ui.crossColorBtn.textContent = state.crossColor ? "CROSS COLOR ON" : "CROSS COLOR OFF";
    if (state.crossColor) {
      setStatus("Cross Color aktif 🎨", 700);
      lastCrossChange = performance.now();
    } else {
      setStatus("Cross Color dimatikan, reset ke putih ⚪", 700);
      for (const h of state.heads) {
        h.color = '#ffffff';
      }
    }
  });
}
function updateCrossColor() {
  if (!state.crossColor) return;
  const now = performance.now();
  const colorA = ui.colorA?.value || '#ffffff';
  const colorB = ui.colorB?.value || '#b300ff';
  const speedSec = parseFloat(ui.crossSpeed?.value || 1);
  const delay = speedSec * 1000;
  if (now - lastCrossChange >= delay) {
    lastCrossChange = now;
    crossColorToggle = !crossColorToggle;
    for (let i = 0; i < state.heads.length; i++) {
      const h = state.heads[i];
      const isEven = i % 2 === 0;
      h.color = crossColorToggle
        ? (isEven ? colorA : colorB)
        : (isEven ? colorB : colorA);
    }
  }
}
requestAnimationFrame(loop);
ui.beamCount && ui.beamCount.addEventListener('input', e=>{ initHeads(Number(e.target.value)); setStatus('Beams '+e.target.value,700); });
ui.dimmer && ui.dimmer.addEventListener('input', ()=> setStatus('Dimmer '+Math.round(Number(ui.dimmer.value))+'%',700));
ui.beamAngle && ui.beamAngle.addEventListener('input', ()=> setStatus('Angle '+ui.beamAngle.value+'°',700));
ui.beamRange && ui.beamRange.addEventListener('input', ()=> setStatus('Range '+ui.beamRange.value+'px',700));
ui.rainbowBtn && ui.rainbowBtn.addEventListener('click', ()=>{
  const on = ui.rainbowBtn.textContent.indexOf('ON') >= 0;
  if(on){ ui.rainbowBtn.textContent = 'RAINBOW OFF'; setStatus('Rainbow OFF',700); } else { ui.rainbowBtn.textContent = 'RAINBOW ON'; setStatus('Rainbow ON',700); }
});
ui.goboBtn && ui.goboBtn.addEventListener('click', ()=>{ const on = ui.goboBtn.textContent.indexOf('ON') >= 0; if(on){ ui.goboBtn.textContent='AURORA OFF'; setStatus('Aurora OFF',700); } else { ui.goboBtn.textContent='AURORA ON'; setStatus('Aurora ON',700); } });
ui.powerBtn && ui.powerBtn.addEventListener('click', ()=>{ state.power = !state.power; ui.powerBtn.textContent = state.power ? 'POWER ON' : 'POWER OFF'; setStatus(state.power ? 'Power ON' : 'Power OFF',700); });
ui.modeSelect && ui.modeSelect.addEventListener('change', (e)=>{ ui.manualArea.style.display = e.target.value === 'manual' ? 'block' : 'none'; setStatus('Mode '+e.target.value,700); });
ui.manualHeadSelect && ui.manualHeadSelect.addEventListener('change', (e)=>{ state.manualSelected = Number(e.target.value); updateManualControls(state.manualSelected); });
ui.manualPan && ui.manualPan.addEventListener('input', (e)=>{ const id = Number(ui.manualHeadSelect.value); const h = state.heads.find(x=>x.id===id); if(h) h.targetPan = Number(e.target.value); });
ui.manualTilt && ui.manualTilt.addEventListener('input', (e)=>{ const id = Number(ui.manualHeadSelect.value); const h = state.heads.find(x=>x.id===id); if(h) h.targetTilt = Number(e.target.value); });
ui.manualColor && ui.manualColor.addEventListener('input', (e)=>{ const id = Number(ui.manualHeadSelect.value); const h = state.heads.find(x=>x.id===id); if(h){ h.color = e.target.value; setStatus('Color set',700); } });
document.addEventListener('DOMContentLoaded', () => {
  const strobeButtons = document.querySelectorAll('.strobe-btn');
  const prismaButtons = document.querySelectorAll('.prisma-btn');
  if (strobeButtons.length > 0) {
    strobeButtons.forEach(btn => {
      btn.addEventListener('click', e => {
        strobeButtons.forEach(b => b.classList.remove('active'));
        e.target.classList.add('active');
        const mode = e.target.dataset.mode;
        state.strobeMode = mode;
        setStatus('Strobe mode: ' + mode, 700);
      });
    });
  }
  if (prismaButtons.length > 0) {
    prismaButtons.forEach(btn => {
      btn.addEventListener('click', e => {
        prismaButtons.forEach(b => b.classList.remove('active'));
        e.target.classList.add('active');
        const mode = e.target.dataset.mode;
        state.prismaMode = mode;
        setStatus('Prisma mode: ' + mode, 700);
      });
    });
  }
  if (ui.strobeSpeed) {
    ui.strobeSpeed.addEventListener('input', e => {
      state.strobeSpeed = Number(e.target.value);
      setStatus('Strobe Speed: ' + e.target.value + ' Hz', 700);
    });
  }
});
document.getElementById('saveHeadA') && document.getElementById('saveHeadA').addEventListener('click', ()=> saveHeadSlot(state.manualSelected, 'A'));
document.getElementById('loadHeadA') && document.getElementById('loadHeadA').addEventListener('click', ()=> loadHeadSlot(state.manualSelected, 'A'));
document.getElementById('saveHeadB') && document.getElementById('saveHeadB').addEventListener('click', ()=> saveHeadSlot(state.manualSelected, 'B'));
document.getElementById('loadHeadB') && document.getElementById('loadHeadB').addEventListener('click', ()=> loadHeadSlot(state.manualSelected, 'B'));
document.getElementById('saveAll') && document.getElementById('saveAll').addEventListener('click', ()=> saveAllSlot('ALL'));
document.getElementById('loadAll') && document.getElementById('loadAll').addEventListener('click', ()=> loadAllSlot('ALL'));
document.getElementById('clearSlots') && document.getElementById('clearSlots').addEventListener('click', ()=> { localStorage.removeItem(STORAGE_KEY); setStatus('Slots cleared',700); });
document.getElementById("miniBruteToggle").addEventListener("click", () => {
  state.miniBruteOn = !state.miniBruteOn;
  setStatus("MiniBrute " + (state.miniBruteOn ? "ON" : "OFF"), 1000);
});
function saveHeadSlot(hid, slot){ const st = loadStorage(); st.heads = st.heads || {}; st.heads[slot] = st.heads[slot] || {}; const h = state.heads.find(x=>x.id===hid); if(h) st.heads[slot][hid] = { pan: h.pan, tilt: h.tilt, color: h.color, ts:Date.now() }; saveStorage(st); }
function loadHeadSlot(hid, slot){ const st = loadStorage(); if(!st.heads || !st.heads[slot] || !st.heads[slot][hid]){ setStatus('Slot empty',800); return; } const s = st.heads[slot][hid]; const h = state.heads.find(x=>x.id===hid); if(h){ h.targetPan = s.pan; h.targetTilt = s.tilt; h.color = s.color || h.color; setStatus('Head loaded',800); } }
function saveAllSlot(slot){ const data = state.heads.map(h=>({id:h.id, pan:h.pan, tilt:h.tilt, color:h.color})); const st = loadStorage(); st.all = st.all || {}; st.all[slot] = {time:Date.now(), heads:data}; saveStorage(st); }
function loadAllSlot(slot){ const st = loadStorage(); if(!st.all || !st.all[slot]){ setStatus('Slot empty',800); return; } const data = st.all[slot].heads; for(const d of data){ const h = state.heads.find(x=>x.id===d.id); if(h){ h.targetPan = d.pan; h.targetTilt = d.tilt; h.color = d.color || h.color; } } setStatus('All loaded',800); }
function setStatus(text, ttl=900){ ui.powerBtn.textContent = text; clearTimeout(ui._t); ui._t = setTimeout(()=> ui.powerBtn.textContent = state.power ? 'POWER ON' : 'POWER OFF', ttl); }
ui.tronVideoFile.addEventListener("change", (e) => {
  const file = e.target.files[0];
  if (!file) return;
  const reader = new FileReader();
  reader.onload = (ev) => {
    createTronMediaElement(ev.target.result, file.type);
    saveTronState(ev.target.result, file.type);
  };
  reader.readAsDataURL(file);
});
function createTronMediaElement(src, type) {
  if (tronMedia) tronMedia.remove();
  if (type.startsWith("video/")) {
    tronMedia = document.createElement("video");
    tronMedia.src = src;
    tronMedia.loop = true;
    tronMedia.muted = true;
    tronMedia.autoplay = true;
    tronMedia.playsInline = true;
    tronMedia.style.display = "none";
    document.body.appendChild(tronMedia);
    tronMedia.addEventListener("loadeddata", () => {
      tronMediaReady = true;
      setStatus("Video Loaded", 1000);
    });
  } else if (type.startsWith("image/")) {
    tronMedia = document.createElement("img");
    tronMedia.src = src;
    tronMedia.style.display = "none";
    document.body.appendChild(tronMedia);
    tronMedia.onload = () => {
      tronMediaReady = true;
      setStatus("Image Loaded", 1000);
    };
  }
}
let tronMedia = null;
let tronMediaReady = false;
function saveTronState(dataURL, type) {
  const st = loadStorage();
  st.tronMedia = { dataURL, type };
  saveStorage(st);
}
function restoreTronState() {
  const st = loadStorage();
  if (st.tronMedia) {
    createTronMediaElement(st.tronMedia.dataURL, st.tronMedia.type);
  }
}
restoreTronState();
if (ui.playTron) ui.playTron.addEventListener("click", () => {
  if (tronMedia && tronMedia.tagName === "VIDEO") tronMedia.play();
});
if (ui.pauseTron) ui.pauseTron.addEventListener("click", () => {
  if (tronMedia && tronMedia.tagName === "VIDEO") tronMedia.pause();
});
if (ui.clearTron) ui.clearTron.addEventListener("click", () => {
  tronMediaReady = false;
  if (tronMedia) {
    if (tronMedia.tagName === "VIDEO") tronMedia.pause();
    tronMedia.remove();
    tronMedia = null;
  }
  const st = loadStorage();
  delete st.tronMedia;
  saveStorage(st);
  setStatus("Cleared", 700);
});
const originalDrawBackground = drawBackground;
drawBackground = function() {
  ctx.fillStyle = "#000";
  ctx.fillRect(0, 0, canvas.width, canvas.height);
  if (tronMediaReady && tronMedia) {
    let w = canvas.width, h = canvas.height;
    let x = 0, y = 0;
    if (tronMedia.videoWidth || tronMedia.naturalWidth) {
      const mediaW = tronMedia.videoWidth || tronMedia.naturalWidth;
      const mediaH = tronMedia.videoHeight || tronMedia.naturalHeight;
      const aspect = mediaW / mediaH;
      const canvasAspect = canvas.width / canvas.height;
      if (aspect > canvasAspect) {
        h = canvas.height;
        w = h * aspect;
      } else {
        w = canvas.width;
        h = w / aspect;
      }
      x = (canvas.width - w) / 2;
      y = (canvas.height - h) / 2;
    }
    ctx.drawImage(tronMedia, x, y, w, h);
    ctx.fillStyle = "rgba(0,0,0,0.10)";
    ctx.fillRect(0, 0, canvas.width, canvas.height);
  }
};
// === GOBO COLOR FX ===
state.goboColorFx = false;
state.goboColors = ['#ff00ff', '#ffffff', '#ff66ff']; // default
state.goboColorShift = 0;

ui.goboColorBtn = document.getElementById('goboColorBtn');
ui.goboColor1 = document.getElementById('goboColor1');
ui.goboColor2 = document.getElementById('goboColor2');
ui.goboColor3 = document.getElementById('goboColor3');

// ON / OFF toggle
ui.goboColorBtn.addEventListener('click', () => {
  state.goboColorFx = !state.goboColorFx;
  ui.goboColorBtn.textContent = state.goboColorFx ? 'GOBO COLOR ON' : 'GOBO COLOR OFF';
  setStatus(state.goboColorFx ? 'Efek Gobo Warna Aktif 🎨' : 'Efek Gobo Warna Dimatikan ⚪', 700);
});
function updateGoboColors() {
  state.goboColors = [ui.goboColor1.value, ui.goboColor2.value, ui.goboColor3.value];
}
ui.goboColor1.addEventListener('input', updateGoboColors);
ui.goboColor2.addEventListener('input', updateGoboColors);
ui.goboColor3.addEventListener('input', updateGoboColors);
function updateGoboColorShift() {
  if (!state.goboColorFx) return;
  state.goboColorShift += 0.005;
  if (state.goboColorShift > 1) state.goboColorShift = 0;
}
ui.wallCount && ui.wallCount.addEventListener('input', (e)=>{ ui.wallCountLabel.textContent = e.target.value; });
ui.spawnWall && ui.spawnWall.addEventListener('click', ()=>{ const v = Number(ui.wallCount.value); spawnWallwashers(v); setStatus('Wallwashers spawned: '+v,800); });
ui.clearWall && ui.clearWall.addEventListener('click', ()=>{ state.wallwashers = []; saveStateUI(); setStatus('Wallwashers cleared',700); });
ui.martinColor.addEventListener("input", (e) => {
  if (!state.martins) return;
  const id = state.selectedMartin ?? 0;
  if (state.martins[id]) state.martins[id].color = e.target.value;
  saveStateUI();
});
ui.martinCount = document.getElementById("martinCount");
ui.martinCountLabel = document.getElementById("martinCountLabel");
ui.spawnMartin = document.getElementById("spawnMartin");
ui.clearMartin = document.getElementById("clearMartin");
ui.martinCount.addEventListener("input", (e) => {
  ui.martinCountLabel.textContent = e.target.value;
});
ui.spawnMartin.addEventListener("click", () => {
  spawnMartins(parseInt(ui.martinCount.value));
});
ui.clearMartin.addEventListener("click", () => {
  state.martins = [];
  saveStateUI();
});
ui.martinScale.addEventListener('input', (e) => {
  if (!state.martins) return;
  const id = state.selectedMartin ?? 0;
  const m = state.martins[id];
  if (m) {
    m.scale = parseFloat(e.target.value);
    saveStateUI();
  }
});
ui.martinRotate.addEventListener('input', (e) => {
  if (!state.martins) return;
  const id = state.selectedMartin ?? 0;
  const m = state.martins[id];
  if (m) {
    m.rotation = parseFloat(e.target.value);
    saveStateUI();
  }
});
ui.martinColorMode.addEventListener("change", (e) => {
  state.martinColorMode = e.target.value;
  saveStateUI();
});
ui.parCount && ui.parCount.addEventListener('input', (e)=>{ ui.parCountLabel.textContent = e.target.value; });
ui.spawnPar && ui.spawnPar.addEventListener('click', ()=>{ const v = Number(ui.parCount.value); spawnParleds(v); setStatus('Parleds spawned: '+v,800); });
ui.clearPar && ui.clearPar.addEventListener('click', ()=>{ state.parleds = []; saveStateUI(); setStatus('Parleds cleared',700); });
if(state.wallwashers.length === 0 && Number(ui.wallCount ? ui.wallCount.value : 0) > 0) spawnWallwashers(Number(ui.wallCount ? ui.wallCount.value : 0));
if(state.parleds.length === 0 && Number(ui.parCount ? ui.parCount.value : 0) > 0) spawnParleds(Number(ui.parCount ? ui.parCount.value : 0));
(function restoreAll(){
  const st = loadStorage();
  if(st.bgImage){}
  if(st.wallwashers) state.wallwashers = st.wallwashers;
  if(st.parleds) state.parleds = st.parleds;
  if(st.miniBrutePos) state.miniBrutePos = st.miniBrutePos;
})();
window.GEBER = { state, initHeads, playChaseSlot, clearChaseSlot };
if(ui.wallScale){
  ui.wallScale.addEventListener('input', ()=>{
    if(state.selectedWall !== null && state.wallwashers){
      const w = state.wallwashers.find(x => x.id === state.selectedWall);
      if(w){ w.scale = Number(ui.wallScale.value); saveStateUI(); setStatus('Wall scale '+ui.wallScale.value,700); }
    }
  });
}
if(ui.wallRotate){
  ui.wallRotate.addEventListener('input', ()=>{
    if(state.selectedWall !== null && state.wallwashers){
      const w = state.wallwashers.find(x => x.id === state.selectedWall);
      if(w){ w.rotation = Number(ui.wallRotate.value); saveStateUI(); setStatus('Wall rotate '+ui.wallRotate.value+'°',700); }
    }
  });
}
canvas.addEventListener('click', (e)=>{
  if(state.dragging) return;
  const r = canvas.getBoundingClientRect(); const px = e.clientX - r.left, py = e.clientY - r.top;
  state.selectedWall = null;
  for(const w of state.wallwashers){
    const barH = Math.round(canvas.height * 0.36) * (w.scale || 1);
    const barW = Math.max(18, Math.round(canvas.width * 0.02)) * (w.scale || 1);
    const dx = px - w.x;
    const dy = py - (w.y - Math.round(canvas.height * 0.36)/2 + (barH/2));
    const rot = (w.rotation || 0) * Math.PI/180;
    const localX = dx * Math.cos(-rot) - dy * Math.sin(-rot);
    const localY = dx * Math.sin(-rot) + dy * Math.cos(-rot);
    if(localX >= -barW/2 - 8 && localX <= barW/2 + 8 && localY >= -barH/2 - 8 && localY <= barH/2 + 8){
      state.selectedWall = w.id;
      ui.wallScale.value = w.scale || 1;
      ui.wallRotate.value = w.rotation || 0;
      setStatus('Selected Wallwasher '+(w.id+1),700);
      break;
    }
  }
});

// =============== SAVE / LOAD PROJECT ===============
function saveProjectToFile() {
  try {
    const projectData = {
      version: "geber-lighting-v1",
      timestamp: Date.now(),
      state: {
        power: state.power,
        presetSpeed: state.presetSpeed,
        dimmer: state.dimmer,
        angle: state.angle,
        range: state.range,
        globalColor: state.globalColor,
        rainbow: state.rainbow,
        gobo: state.gobo,
        strobeMode: state.strobeMode,
        strobeSpeed: state.strobeSpeed,
        prismaMode: state.prismaMode,
        prismaRotate: state.prismaRotate,
        presetActive: [...state.presetActive],
        heads: state.heads.map(h => ({ ...h })),
        wallwashers: state.wallwashers.map(w => ({ ...w })),
        parleds: state.parleds.map(p => ({ ...p })),
        martins: state.martins ? state.martins.map(m => ({ ...m })) : [],
        miniBrutes: state.miniBrutes ? state.miniBrutes.map(mb => ({ ...mb })) : [],
        miniBruteOn: state.miniBruteOn,
        crossColor: state.crossColor,
        goboColorFx: state.goboColorFx,
        goboColors: [...state.goboColors],
        martinColorMode: state.martinColorMode,
        // UI values
        beamCount: Number(ui.beamCount.value || 8),
        wallCount: Number(ui.wallCount.value || 0),
        parCount: Number(ui.parCount.value || 0),
        martinCount: Number(ui.martinCount.value || 0),
        // Custom cross color
        colorA: ui.colorA.value,
        colorB: ui.colorB.value,
        crossSpeed: ui.crossSpeed.value,
        // Gobo color
        goboColor1: ui.goboColor1.value,
        goboColor2: ui.goboColor2.value,
        goboColor3: ui.goboColor3.value,
      }
    };

    const blob = new Blob([JSON.stringify(projectData, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = `geber_project_${new Date().toISOString().slice(0,16).replace(/:/g,'-')}.geber`;
    document.body.appendChild(a);
    a.click();
    setTimeout(() => {
      document.body.removeChild(a);
      URL.revokeObjectURL(url);
    }, 100);
    setStatus('Project saved!', 1200);
  } catch (e) {
    console.error("Save failed:", e);
    setStatus('Save failed!', 1200);
  }
}

function loadProjectFromFile(file) {
  const reader = new FileReader();
  reader.onload = function(e) {
    try {
      const data = JSON.parse(e.target.result);
      if (!data.version || !data.state) throw new Error("Invalid project file");
      const s = data.state;

      // Restore state
      state.power = s.power ?? true;
      state.presetSpeed = s.presetSpeed ?? 1.0;
      state.dimmer = s.dimmer ?? 0.95;
      state.angle = s.angle ?? 12;
      state.range = s.range ?? 900;
      state.globalColor = s.globalColor ?? '#ffffff';
      state.rainbow = s.rainbow ?? false;
      state.gobo = s.gobo ?? false;
      state.strobeMode = s.strobeMode ?? 'off';
      state.strobeSpeed = s.strobeSpeed ?? 14;
      state.prismaMode = s.prismaMode ?? 'none';
      state.prismaRotate = s.prismaRotate ?? false;
      state.presetActive = s.presetActive ? [...s.presetActive] : new Array(13).fill(false);
      state.crossColor = s.crossColor ?? false;
      state.goboColorFx = s.goboColorFx ?? false;
      state.goboColors = s.goboColors ? [...s.goboColors] : ['#ff00ff', '#ffffff', '#ff66ff'];
      state.martinColorMode = s.martinColorMode ?? 'global';
      state.miniBruteOn = s.miniBruteOn ?? false;

      state.heads = s.heads ? s.heads.map(h => ({ ...h })) : [];
      state.wallwashers = s.wallwashers ? s.wallwashers.map(w => ({ ...w })) : [];
      state.parleds = s.parleds ? s.parleds.map(p => ({ ...p })) : [];
      state.martins = s.martins ? s.martins.map(m => ({ ...m })) : [];
      state.miniBrutes = s.miniBrutes ? s.miniBrutes.map(mb => ({ ...mb })) : [];

      // Update UI
      ui.beamCount.value = s.beamCount ?? state.heads.length;
      ui.wallCount.value = s.wallCount ?? state.wallwashers.length;
      ui.parCount.value = s.parCount ?? state.parleds.length;
      ui.martinCount.value = s.martinCount ?? (state.martins?.length || 0);
      ui.beamCountLabel.textContent = s.beamCount ?? state.heads.length;
      ui.wallCountLabel.textContent = s.wallCount ?? state.wallwashers.length;
      ui.parCountLabel.textContent = s.parCount ?? state.parleds.length;
      ui.martinCountLabel.textContent = s.martinCount ?? (state.martins?.length || 0);

      ui.powerBtn.textContent = state.power ? 'POWER ON' : 'POWER OFF';
      ui.rainbowBtn.textContent = state.rainbow ? 'RAINBOW ON' : 'RAINBOW OFF';
      ui.goboBtn.textContent = state.gobo ? 'AURORA ON' : 'AURORA OFF';
      ui.crossColorBtn.textContent = state.crossColor ? 'CROSS COLOR ON' : 'CROSS COLOR OFF';
      ui.goboColorBtn.textContent = state.goboColorFx ? 'GOBO COLOR ON' : 'GOBO COLOR OFF';
      ui.miniBruteToggle.textContent = state.miniBruteOn ? 'BRUTE ON' : 'BRUTE OFF';

      // Update prisma & strobe buttons
      document.querySelectorAll('.prisma-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.mode === state.prismaMode);
      });
      document.querySelectorAll('.strobe-btn').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.mode === state.strobeMode);
      });

      // Update custom colors
      if (s.colorA) ui.colorA.value = s.colorA;
      if (s.colorB) ui.colorB.value = s.colorB;
      if (s.crossSpeed) {
        ui.crossSpeed.value = s.crossSpeed;
        ui.crossSpeedLabel.textContent = Number(s.crossSpeed).toFixed(1);
      }
      if (s.goboColor1) ui.goboColor1.value = s.goboColor1;
      if (s.goboColor2) ui.goboColor2.value = s.goboColor2;
      if (s.goboColor3) ui.goboColor3.value = s.goboColor3;

      buildManualSelect();
      buildPresetsUI();
      const faders = document.querySelectorAll('.presetFader');
      state.presetActive.forEach((active, i) => {
        if (faders[i]) faders[i].value = active ? 100 : 0;
      });

      setStatus('Project loaded!', 1500);
    } catch (err) {
      console.error("Load failed:", err);
      setStatus('Invalid project file!', 1500);
    }
  };
  reader.readAsText(file);
}

document.getElementById('saveProjectBtn').addEventListener('click', saveProjectToFile);
document.getElementById('loadProjectBtn').addEventListener('click', () => {
  document.getElementById('loadProjectInput').click();
});
document.getElementById('loadProjectInput').addEventListener('change', (e) => {
  const file = e.target.files[0];
  if (file) {
    loadProjectFromFile(file);
    e.target.value = '';
  }
});
</script>
</body>
</html>